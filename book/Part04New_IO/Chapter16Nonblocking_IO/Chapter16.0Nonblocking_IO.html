<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Chapter 16.0 Nonblocking I/O</title>
	<link rel="stylesheet" type="text/css" href="../../styles.css">
	<link rel="stylesheet" type="text/css" href="../../highlight/desert.css">
	<script language="javascript" src="../../highlight/prettify.js" ></script>
  </head>
  
  <body onload="prettyPrint()" >
	<h1>Chapter 16.0 非阻塞I/O(Nonblocking I/O)</h1>
	<pre >
		非阻塞I/O是new I/O最重要的特性之一.使用传统基于流的I/O无论你读写的是硬盘
	还是网络,速度都会受其限制.通常代码不得不停下来等待网络或硬盘的响应.当程序需要
	做很多不同事情的时候,这会变成个大麻烦,比如一个网络服务器可能需要同时服务几百
	上千个客户端.它不希望一个较慢的连接拖缓所有其他连接的速度.
		
		对于这个问题传统的解决办法是给每一个连接启动单独的线程.一百个并发的连接就
	需要一百个线程.但是,尽管线程比进程要轻量级,但它们仍然有基本的性能开销.启动和关闭
	线程需要时间,而且每个线程都会占用一定的系统资源.比如,在一些版本的Windows上,每个
	线程都会占用大概1MB的栈空间.所以,如果你想在一个只有1G内存的系统上启动2000个线程,
	那么你会遇到非常严重的内存问题(这还不包括除线程栈以外任何的内存需要).线程池可以
	改善这种情况,也许能让你同时处理原先两倍的连接,但并不足够让你无视线程的开销.
	
		幸运的是,基于缓存和通道的新I/O终于登场来拯救世界了.作为后面两个字母所代表的
	同步阻塞I/O的补充,NIO也支持非阻塞I/O.在非阻塞I/O中,一个线程可以管理很多不同的连接,
	与等待每一个任务处理完成不同,线程会询问哪个通道做好了读写的准备且不会遇到阻塞.
	之后它会读写事先已得知的不会阻塞的通道,然后如此反复.在大型服务器上,这种机制能轻松
	处理之前三倍以上任务数.
	
		非阻塞I/O主要涉及网络连接.在线程之间传递数据的Pipe通道也支持非阻塞I/O.文件
	通道不支持非阻塞I/O,因为与网络连接相比,文件访问并不会经常阻塞,而且大多数现代硬盘
	控制器的速度都能保证cpu填满数据高效运作.此外,一个同时读写几百个文件的程序并不多见.
	但是在网络服务器上,这种使用是基本规则,而不是特例.
	</pre>
  </body>
</html>
