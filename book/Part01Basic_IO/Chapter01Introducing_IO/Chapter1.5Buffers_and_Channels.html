<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Chapter 1.5  Buffers and Channels</title>
	<link rel="stylesheet" type="text/css" href="../../styles.css">
	<link rel="stylesheet" type="text/css" href="../../highlight/desert.css">
	<script language="javascript" src="../../highlight/prettify.js" ></script>
  </head>
  
  <body>
    <h2>Chapter 1.5 缓存和通道(Buffers and Channels)</h2>
	<pre>
		只要一个程序在同一时间读或写的东西程序只有一个,流的速度是相当快的.实际上,
	瓶颈更多是在硬盘读写和网络速度上,而不是Java程序自身.但是当一个程序要同时读写多个流
	的时候,情况就有些不一样了.这种情况在web服务器上经常发生,例如,一个处理器应用可能会
	与上百个甚至数千个客户端同时通信.
	
		在任何时候,流都可能阻塞(block).就是说,它会暂时停止接受更多的请求来等待实际
	硬件的读或写赶上它的速度.这可能发生在磁盘上,更是网络连接的重大问题.很明显,你不想因
	为一个人的网络拥堵就停止对999个客户端发送数据.在Java1.4之前传统的解决方法是给每个
	连接分配一个不同的线程.500个客户端就需要500个线程.每个线程可以独立运行,所以其他线
	程的连接缓慢不会导致每个线程都减慢速度.
	
		但是,多线程不是无开销的.创建和管理线程需要做很多工作,而且很少有虚拟机能同时
	处理超过1000个线程或创建如此多的线程而不造成严重的性能下降.创建数千个线程会使最健
	壮的虚拟机都崩溃掉.不过,大型服务器需要有同时与数千个客户沟通的能力.
	
		在Java1.4中发明的解决方案是非阻塞I/O(nonblocking I/O).在非阻塞I/O中,流被转移
	到一个支持的角色,主要的工作都是由缓存和通道来完成.输入缓存(Input buffer)由通道填充
	数据,再由程序将其排出.输出缓存(Output buffer)做的事情正好相反:由程序填充数据,再向
	目标倒出.这种设计是为了让reader和writer不需要总是在操作数据的时候保持同步.更重要的
	是,客户端程序可以排队读写每个通道.而不是在另一端的通道还没准备好的时候停止处理.这
	可以使一个线程同时处理多个通道,极大的减少了JVM的负载.
	
		通道和缓存同样能用在内存映射I/O中.在内存映射I/O中,文件被当做大块的内存来处理,
	基本上是很大的byte数组.被映射文件的特定部分可以用int x = file.getInt(1067)的方式来
	读取,也可以用file.putInt(x, 1067)来写入.数据会直接存储在正确的硬盘位置,而不再需要
	读取数据前后相关的所有内容.
	
		通道和缓存要比流和字节稍微复杂些.然而,对于某些I/O密集型的应用程序来说,它们
	带来的性能提升是显著的,值得增加复杂性.
		
	</pre>
  </body>
</html>
